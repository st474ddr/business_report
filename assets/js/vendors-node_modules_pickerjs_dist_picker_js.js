/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk"] = self["webpackChunk"] || []).push([["vendors-node_modules_pickerjs_dist_picker_js"],{

/***/ "../node_modules/pickerjs/dist/picker.js":
/*!***********************************************!*\
  !*** ../node_modules/pickerjs/dist/picker.js ***!
  \***********************************************/
/***/ (function(module) {

eval("/*!\n * Picker.js v1.2.1\n * https://fengyuanchen.github.io/pickerjs\n *\n * Copyright 2016-present Chen Fengyuan\n * Released under the MIT license\n *\n * Date: 2019-02-18T13:08:12.801Z\n */\n(function (global, factory) {\n   true ? module.exports = factory() : 0;\n})(this, function () {\n  'use strict';\n\n  function _typeof(obj) {\n    if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n      _typeof = function (obj) {\n        return typeof obj;\n      };\n    } else {\n      _typeof = function (obj) {\n        return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n      };\n    }\n\n    return _typeof(obj);\n  }\n\n  function _classCallCheck(instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  }\n\n  function _defineProperties(target, props) {\n    for (var i = 0; i < props.length; i++) {\n      var descriptor = props[i];\n      descriptor.enumerable = descriptor.enumerable || false;\n      descriptor.configurable = true;\n      if (\"value\" in descriptor) descriptor.writable = true;\n      Object.defineProperty(target, descriptor.key, descriptor);\n    }\n  }\n\n  function _createClass(Constructor, protoProps, staticProps) {\n    if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n    if (staticProps) _defineProperties(Constructor, staticProps);\n    return Constructor;\n  }\n\n  function _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();\n  }\n\n  function _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) {\n      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n      return arr2;\n    }\n  }\n\n  function _iterableToArray(iter) {\n    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter);\n  }\n\n  function _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance\");\n  }\n\n  var DEFAULTS = {\n    // Define the container for putting the picker.\n    container: null,\n    // Indicate whether show the prev and next arrow controls on each column.\n    controls: false,\n    // The initial date. If not present, use the current date.\n    date: null,\n    // The date string format, also as the sorting order for columns.\n    format: 'YYYY-MM-DD HH:mm',\n    // Indicate whether show the column headers.\n    headers: false,\n    // Define the increment for each date / time part.\n    increment: 1,\n    // Enable inline mode.\n    inline: false,\n    // Define the language. (An ISO language code).\n    language: '',\n    // Months' name.\n    months: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'],\n    // Shorter months' name.\n    monthsShort: ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'],\n    // Define the number of rows for showing.\n    rows: 5,\n    // Define the text of the picker.\n    text: {\n      title: 'Pick a date and time',\n      cancel: 'Cancel',\n      confirm: 'OK',\n      year: 'Year',\n      month: 'Month',\n      day: 'Day',\n      hour: 'Hour',\n      minute: 'Minute',\n      second: 'Second',\n      millisecond: 'Millisecond'\n    },\n    // Translate date / time text.\n    translate: function translate(type, text) {\n      return text;\n    },\n    // Shortcuts of custom events.\n    show: null,\n    shown: null,\n    hide: null,\n    hidden: null,\n    pick: null\n  };\n  var TEMPLATE = '<div class=\"picker\" data-picker-action=\"hide\" touch-action=\"none\" tabindex=\"-1\" role=\"dialog\">' + '<div class=\"picker-dialog\" role=\"document\">' + '<div class=\"picker-header\">' + '<h4 class=\"picker-title\">{{ title }}</h4>' + '<button type=\"button\" class=\"picker-close\" data-picker-action=\"hide\" aria-label=\"Close\">&times;</button>' + '</div>' + '<div class=\"picker-body\">' + '<div class=\"picker-grid\"></div>' + '</div>' + '<div class=\"picker-footer\">' + '<button type=\"button\" class=\"picker-cancel\" data-picker-action=\"hide\">{{ cancel }}</button>' + '<button type=\"button\" class=\"picker-confirm\" data-picker-action=\"pick\">{{ confirm }}</button>' + '</div>' + '</div>' + '</div>';\n  var IS_BROWSER = typeof window !== 'undefined';\n  var WINDOW = IS_BROWSER ? window : {};\n  var IS_TOUCH_DEVICE = IS_BROWSER ? 'ontouchstart' in WINDOW.document.documentElement : false;\n  var HAS_POINTER_EVENT = IS_BROWSER ? 'PointerEvent' in WINDOW : false;\n  var NAMESPACE = 'picker';\n  var LANGUAGES = {}; // Actions\n\n  var ACTION_HIDE = 'hide';\n  var ACTION_NEXT = 'next';\n  var ACTION_PICK = 'pick';\n  var ACTION_PREV = 'prev'; // Classes\n\n  var CLASS_OPEN = \"\".concat(NAMESPACE, \"-open\");\n  var CLASS_OPENED = \"\".concat(NAMESPACE, \"-opened\");\n  var CLASS_PICKED = \"\".concat(NAMESPACE, \"-picked\"); // Data keys\n  // Add namespace to avoid to conflict to some other libraries.\n\n  var DATA_ACTION = \"\".concat(NAMESPACE, \"Action\");\n  var DATA_TOKEN = 'token';\n  var DATA_TYPE = 'type';\n  var DATA_NAME = 'name';\n  var DATA_VALUE = 'value'; // Events\n\n  var EVENT_CLICK = 'click';\n  var EVENT_FOCUS = 'focus';\n  var EVENT_HIDDEN = 'hidden';\n  var EVENT_HIDE = 'hide';\n  var EVENT_KEY_DOWN = 'keydown';\n  var EVENT_PICK = 'pick';\n  var EVENT_TOUCH_START = IS_TOUCH_DEVICE ? 'touchstart' : 'mousedown';\n  var EVENT_TOUCH_MOVE = IS_TOUCH_DEVICE ? 'touchmove' : 'mousemove';\n  var EVENT_TOUCH_END = IS_TOUCH_DEVICE ? 'touchend touchcancel' : 'mouseup';\n  var EVENT_POINTER_DOWN = HAS_POINTER_EVENT ? 'pointerdown' : EVENT_TOUCH_START;\n  var EVENT_POINTER_MOVE = HAS_POINTER_EVENT ? 'pointermove' : EVENT_TOUCH_MOVE;\n  var EVENT_POINTER_UP = HAS_POINTER_EVENT ? 'pointerup pointercancel' : EVENT_TOUCH_END;\n  var EVENT_SHOW = 'show';\n  var EVENT_SHOWN = 'shown';\n  var EVENT_WHEEL = 'wheel mousewheel DOMMouseScroll';\n  var _Object$prototype = Object.prototype,\n      hasOwnProperty = _Object$prototype.hasOwnProperty,\n      toString = _Object$prototype.toString;\n  /**\n   * Detect the type of the given value.\n   * @param {*} value - The value to detect.\n   * @returns {string} Returns the type.\n   */\n\n  function typeOf(value) {\n    return toString.call(value).slice(8, -1).toLowerCase();\n  }\n  /**\n   * Check if the given value is a string.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a string, else `false`.\n   */\n\n\n  function isString(value) {\n    return typeof value === 'string';\n  }\n  /**\n   * Check if the given value is finite.\n   */\n\n\n  var isFinite = Number.isFinite || WINDOW.isFinite;\n  /**\n   * Check if the given value is not a number.\n   */\n\n  var isNaN = Number.isNaN || WINDOW.isNaN;\n  /**\n   * Check if the given value is a number.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a number, else `false`.\n   */\n\n  function isNumber(value) {\n    return typeof value === 'number' && !isNaN(value);\n  }\n  /**\n   * Check if the given value is an object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is an object, else `false`.\n   */\n\n\n  function isObject(value) {\n    return _typeof(value) === 'object' && value !== null;\n  }\n  /**\n   * Check if the given value is a plain object.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a plain object, else `false`.\n   */\n\n\n  function isPlainObject(value) {\n    if (!isObject(value)) {\n      return false;\n    }\n\n    try {\n      var _constructor = value.constructor;\n      var prototype = _constructor.prototype;\n      return _constructor && prototype && hasOwnProperty.call(prototype, 'isPrototypeOf');\n    } catch (error) {\n      return false;\n    }\n  }\n  /**\n   * Check if the given value is a function.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a function, else `false`.\n   */\n\n\n  function isFunction(value) {\n    return typeof value === 'function';\n  }\n  /**\n   * Check if the given value is a date.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a date, else `false`.\n   */\n\n\n  function isDate(value) {\n    return typeOf(value) === 'date';\n  }\n  /**\n   * Check if the given value is a valid date.\n   * @param {*} value - The value to check.\n   * @returns {boolean} Returns `true` if the given value is a valid date, else `false`.\n   */\n\n\n  function isValidDate(value) {\n    return isDate(value) && value.toString() !== 'Invalid Date';\n  }\n  /**\n   * Iterate the given data.\n   * @param {*} data - The data to iterate.\n   * @param {Function} callback - The process function for each element.\n   * @returns {*} The original data.\n   */\n\n\n  function forEach(data, callback) {\n    if (data && isFunction(callback)) {\n      if (Array.isArray(data) || isNumber(data.length)\n      /* array-like */\n      ) {\n          var length = data.length;\n          var i;\n\n          for (i = 0; i < length; i += 1) {\n            if (callback.call(data, data[i], i, data) === false) {\n              break;\n            }\n          }\n        } else if (isObject(data)) {\n        Object.keys(data).forEach(function (key) {\n          callback.call(data, data[key], key, data);\n        });\n      }\n    }\n\n    return data;\n  }\n  /**\n   * Recursively assigns own enumerable properties of source objects to the target object.\n   * @param {Object} target - The target object.\n   * @param {Object[]} sources - The source objects.\n   * @returns {Object} The target object.\n   */\n\n\n  function deepAssign(target) {\n    for (var _len = arguments.length, sources = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      sources[_key - 1] = arguments[_key];\n    }\n\n    if (isObject(target) && sources.length > 0) {\n      sources.forEach(function (source) {\n        if (isObject(source)) {\n          Object.keys(source).forEach(function (key) {\n            if (isPlainObject(target[key]) && isPlainObject(source[key])) {\n              target[key] = deepAssign({}, target[key], source[key]);\n            } else {\n              target[key] = source[key];\n            }\n          });\n        }\n      });\n    }\n\n    return target;\n  }\n  /**\n   * Add classes to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be added.\n   */\n\n\n  function addClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        addClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.add(value);\n      return;\n    }\n\n    var className = element.className.trim();\n\n    if (!className) {\n      element.className = value;\n    } else if (className.indexOf(value) < 0) {\n      element.className = \"\".concat(className, \" \").concat(value);\n    }\n  }\n  /**\n   * Remove classes from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} value - The classes to be removed.\n   */\n\n\n  function removeClass(element, value) {\n    if (!value) {\n      return;\n    }\n\n    if (isNumber(element.length)) {\n      forEach(element, function (elem) {\n        removeClass(elem, value);\n      });\n      return;\n    }\n\n    if (element.classList) {\n      element.classList.remove(value);\n      return;\n    }\n\n    if (element.className.indexOf(value) >= 0) {\n      element.className = element.className.replace(value, '');\n    }\n  }\n\n  var REGEXP_HYPHENATE = /([a-z\\d])([A-Z])/g;\n  /**\n   * Transform the given string from camelCase to kebab-case\n   * @param {string} value - The value to transform.\n   * @returns {string} The transformed value.\n   */\n\n  function hyphenate(value) {\n    return value.replace(REGEXP_HYPHENATE, '$1-$2').toLowerCase();\n  }\n  /**\n   * Get data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to get.\n   * @returns {string} The data value.\n   */\n\n\n  function getData(element, name) {\n    if (isObject(element[name])) {\n      return element[name];\n    }\n\n    if (element.dataset) {\n      return element.dataset[name];\n    }\n\n    return element.getAttribute(\"data-\".concat(hyphenate(name)));\n  }\n  /**\n   * Set data to the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to set.\n   * @param {string} data - The data value.\n   */\n\n\n  function setData(element, name, data) {\n    if (isObject(data)) {\n      element[name] = data;\n    } else if (element.dataset) {\n      element.dataset[name] = data;\n    } else {\n      element.setAttribute(\"data-\".concat(hyphenate(name)), data);\n    }\n  }\n  /**\n   * Remove data from the given element.\n   * @param {Element} element - The target element.\n   * @param {string} name - The data key to remove.\n   */\n\n\n  function removeData(element, name) {\n    if (isObject(element[name])) {\n      try {\n        delete element[name];\n      } catch (error) {\n        element[name] = undefined;\n      }\n    } else if (element.dataset) {\n      // #128 Safari not allows to delete dataset property\n      try {\n        delete element.dataset[name];\n      } catch (error) {\n        element.dataset[name] = undefined;\n      }\n    } else {\n      element.removeAttribute(\"data-\".concat(hyphenate(name)));\n    }\n  }\n\n  var REGEXP_SPACES = /\\s\\s*/;\n\n  var onceSupported = function () {\n    var supported = false;\n\n    if (IS_BROWSER) {\n      var once = false;\n\n      var listener = function listener() {};\n\n      var options = Object.defineProperty({}, 'once', {\n        get: function get() {\n          supported = true;\n          return once;\n        },\n\n        /**\n         * This setter can fix a `TypeError` in strict mode\n         * {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Errors/Getter_only}\n         * @param {boolean} value - The value to set\n         */\n        set: function set(value) {\n          once = value;\n        }\n      });\n      WINDOW.addEventListener('test', listener, options);\n      WINDOW.removeEventListener('test', listener, options);\n    }\n\n    return supported;\n  }();\n  /**\n   * Remove event listener from the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n\n  function removeListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (!onceSupported) {\n        var listeners = element.listeners;\n\n        if (listeners && listeners[event] && listeners[event][listener]) {\n          handler = listeners[event][listener];\n          delete listeners[event][listener];\n\n          if (Object.keys(listeners[event]).length === 0) {\n            delete listeners[event];\n          }\n\n          if (Object.keys(listeners).length === 0) {\n            delete element.listeners;\n          }\n        }\n      }\n\n      element.removeEventListener(event, handler, options);\n    });\n  }\n  /**\n   * Add event listener to the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Function} listener - The event listener.\n   * @param {Object} options - The event options.\n   */\n\n\n  function addListener(element, type, listener) {\n    var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    var _handler = listener;\n    type.trim().split(REGEXP_SPACES).forEach(function (event) {\n      if (options.once && !onceSupported) {\n        var _element$listeners = element.listeners,\n            listeners = _element$listeners === void 0 ? {} : _element$listeners;\n\n        _handler = function handler() {\n          delete listeners[event][listener];\n          element.removeEventListener(event, _handler, options);\n\n          for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n            args[_key2] = arguments[_key2];\n          }\n\n          listener.apply(element, args);\n        };\n\n        if (!listeners[event]) {\n          listeners[event] = {};\n        }\n\n        if (listeners[event][listener]) {\n          element.removeEventListener(event, listeners[event][listener], options);\n        }\n\n        listeners[event][listener] = _handler;\n        element.listeners = listeners;\n      }\n\n      element.addEventListener(event, _handler, options);\n    });\n  }\n  /**\n   * Dispatch event on the target element.\n   * @param {Element} element - The event target.\n   * @param {string} type - The event type(s).\n   * @param {Object} data - The additional event data.\n   * @returns {boolean} Indicate if the event is default prevented or not.\n   */\n\n\n  function dispatchEvent(element, type, data) {\n    var event; // Event and CustomEvent on IE9-11 are global objects, not constructors\n\n    if (isFunction(Event) && isFunction(CustomEvent)) {\n      event = new CustomEvent(type, {\n        detail: data,\n        bubbles: true,\n        cancelable: true\n      });\n    } else {\n      event = document.createEvent('CustomEvent');\n      event.initCustomEvent(type, true, true, data);\n    }\n\n    return element.dispatchEvent(event);\n  }\n  /**\n   * Check if the given year is a leap year.\n   * @param {number} year - The year to check.\n   * @returns {boolean} Returns `true` if the given year is a leap year, else `false`.\n   */\n\n\n  function isLeapYear(year) {\n    return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;\n  }\n  /**\n   * Get days number of the given month.\n   * @param {number} year - The target year.\n   * @param {number} month - The target month.\n   * @returns {number} Returns days number.\n   */\n\n\n  function getDaysInMonth(year, month) {\n    return [31, isLeapYear(year) ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31][month];\n  }\n  /**\n   * Add leading zeroes to the given value\n   * @param {number} value - The value to add.\n   * @param {number} [length=1] - The number of the leading zeroes.\n   * @returns {string} Returns converted value.\n   */\n\n\n  function addLeadingZero(value) {\n    var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    var str = String(Math.abs(value));\n    var i = str.length;\n    var result = '';\n\n    if (value < 0) {\n      result += '-';\n    }\n\n    while (i < length) {\n      i += 1;\n      result += '0';\n    }\n\n    return result + str;\n  }\n  /**\n   * Map token to type name\n   * @param {string} token - The token to map.\n   * @returns {string} Returns mapped type name.\n   */\n\n\n  function tokenToType(token) {\n    return {\n      Y: 'year',\n      M: 'month',\n      D: 'day',\n      H: 'hour',\n      m: 'minute',\n      s: 'second',\n      S: 'millisecond'\n    }[token.charAt(0)];\n  }\n\n  var REGEXP_TOKENS = /(Y|M|D|H|m|s|S)\\1*/g;\n  /**\n   * Parse date format.\n   * @param {string} format - The format to parse.\n   * @returns {Object} Returns parsed format data.\n   */\n\n  function parseFormat(format) {\n    var tokens = format.match(REGEXP_TOKENS);\n\n    if (!tokens) {\n      throw new Error('Invalid format.');\n    } // Remove duplicate tokens (#22)\n\n\n    tokens = tokens.filter(function (token, index) {\n      return tokens.indexOf(token) === index;\n    });\n    var result = {\n      tokens: tokens\n    };\n    tokens.forEach(function (token) {\n      result[tokenToType(token)] = token;\n    });\n    return result;\n  }\n\n  var events = {\n    bind: function bind() {\n      var element = this.element,\n          options = this.options,\n          grid = this.grid;\n\n      if (isFunction(options.show)) {\n        addListener(element, EVENT_SHOW, options.show);\n      }\n\n      if (isFunction(options.shown)) {\n        addListener(element, EVENT_SHOWN, options.shown);\n      }\n\n      if (isFunction(options.hide)) {\n        addListener(element, EVENT_HIDE, options.hide);\n      }\n\n      if (isFunction(options.hidden)) {\n        addListener(element, EVENT_HIDDEN, options.hidden);\n      }\n\n      if (isFunction(options.pick)) {\n        addListener(element, EVENT_PICK, options.pick);\n      }\n\n      addListener(element, EVENT_FOCUS, this.onFocus = this.focus.bind(this));\n      addListener(element, EVENT_CLICK, this.onFocus);\n      addListener(this.picker, EVENT_CLICK, this.onClick = this.click.bind(this));\n      addListener(grid, EVENT_WHEEL, this.onWheel = this.wheel.bind(this));\n      addListener(grid, EVENT_POINTER_DOWN, this.onPointerDown = this.pointerdown.bind(this));\n      addListener(document, EVENT_POINTER_MOVE, this.onPointerMove = this.pointermove.bind(this));\n      addListener(document, EVENT_POINTER_UP, this.onPointerUp = this.pointerup.bind(this));\n      addListener(document, EVENT_KEY_DOWN, this.onKeyDown = this.keydown.bind(this));\n    },\n    unbind: function unbind() {\n      var element = this.element,\n          options = this.options,\n          grid = this.grid;\n\n      if (isFunction(options.show)) {\n        removeListener(element, EVENT_SHOW, options.show);\n      }\n\n      if (isFunction(options.shown)) {\n        removeListener(element, EVENT_SHOWN, options.shown);\n      }\n\n      if (isFunction(options.hide)) {\n        removeListener(element, EVENT_HIDE, options.hide);\n      }\n\n      if (isFunction(options.hidden)) {\n        removeListener(element, EVENT_HIDDEN, options.hidden);\n      }\n\n      if (isFunction(options.pick)) {\n        removeListener(element, EVENT_PICK, options.pick);\n      }\n\n      removeListener(element, EVENT_FOCUS, this.onFocus);\n      removeListener(element, EVENT_CLICK, this.onFocus);\n      removeListener(this.picker, EVENT_CLICK, this.onClick);\n      removeListener(grid, EVENT_WHEEL, this.onWheel);\n      removeListener(grid, EVENT_POINTER_DOWN, this.onPointerDown);\n      removeListener(document, EVENT_POINTER_MOVE, this.onPointerMove);\n      removeListener(document, EVENT_POINTER_UP, this.onPointerUp);\n      removeListener(document, EVENT_KEY_DOWN, this.onKeyDown);\n    }\n  };\n  var handlers = {\n    focus: function focus(event) {\n      event.target.blur();\n      this.show();\n    },\n    click: function click(event) {\n      var target = event.target;\n      var action = getData(target, DATA_ACTION);\n\n      switch (action) {\n        case ACTION_HIDE:\n          this.hide();\n          break;\n\n        case ACTION_PICK:\n          this.pick();\n          break;\n\n        case ACTION_PREV:\n        case ACTION_NEXT:\n          this[action](getData(target.parentElement, DATA_TYPE));\n          break;\n\n        default:\n      }\n    },\n    wheel: function wheel(event) {\n      var target = event.target;\n\n      if (target === this.grid) {\n        return;\n      }\n\n      event.preventDefault();\n\n      while (target.parentElement && target.parentElement !== this.grid) {\n        target = target.parentElement;\n      }\n\n      var type = getData(target, DATA_TYPE);\n\n      if (event.deltaY < 0) {\n        this.prev(type);\n      } else {\n        this.next(type);\n      }\n    },\n    pointerdown: function pointerdown(event) {\n      var target = event.target;\n\n      if (target === this.grid || getData(target, DATA_ACTION)) {\n        return;\n      } // This line is required for preventing page scrolling in iOS browsers\n\n\n      event.preventDefault();\n\n      while (target.parentElement && target.parentElement !== this.grid) {\n        target = target.parentElement;\n      }\n\n      var list = target.querySelector(\".\".concat(NAMESPACE, \"-list\"));\n      var itemHeight = list.firstElementChild.offsetHeight;\n      this.cell = {\n        elem: target,\n        list: list,\n        moveY: 0,\n        maxMoveY: itemHeight,\n        minMoveY: itemHeight / 2,\n        startY: event.changedTouches ? event.changedTouches[0].pageY : event.pageY,\n        type: getData(target, DATA_TYPE)\n      };\n    },\n    pointermove: function pointermove(event) {\n      var cell = this.cell;\n\n      if (!cell) {\n        return;\n      }\n\n      event.preventDefault();\n      var endY = event.changedTouches ? event.changedTouches[0].pageY : event.pageY;\n      var moveY = cell.moveY + (endY - cell.startY);\n      cell.startY = endY;\n      cell.moveY = moveY;\n\n      if (Math.abs(moveY) < cell.maxMoveY) {\n        cell.list.style.top = \"\".concat(moveY, \"px\");\n        return;\n      }\n\n      cell.list.style.top = 0;\n      cell.moveY = 0;\n\n      if (moveY >= cell.maxMoveY) {\n        this.prev(cell.type);\n      } else if (moveY <= -cell.maxMoveY) {\n        this.next(cell.type);\n      }\n    },\n    pointerup: function pointerup(event) {\n      var cell = this.cell;\n\n      if (!cell) {\n        return;\n      }\n\n      event.preventDefault();\n      cell.list.style.top = 0;\n\n      if (cell.moveY >= cell.minMoveY) {\n        this.prev(cell.type);\n      } else if (cell.moveY <= -cell.minMoveY) {\n        this.next(cell.type);\n      }\n\n      this.cell = null;\n    },\n    keydown: function keydown(event) {\n      if (this.shown && (event.key === 'Escape' || event.keyCode === 27)) {\n        this.hide();\n      }\n    }\n  };\n  var helpers = {\n    render: function render(type) {\n      var _this = this;\n\n      if (!type) {\n        this.format.tokens.forEach(function (token) {\n          return _this.render(tokenToType(token));\n        });\n        return;\n      }\n\n      var options = this.options;\n      var data = this.data[type];\n      var current = this.current(type);\n      var max = isFunction(data.max) ? data.max() : data.max;\n      var min = isFunction(data.min) ? data.min() : data.min;\n      var base = 0;\n\n      if (isFinite(max)) {\n        base = min > 0 ? max : max + 1;\n      }\n\n      data.list.innerHTML = '';\n      data.current = current;\n\n      for (var i = 0; i < options.rows + 2; i += 1) {\n        var item = document.createElement('li');\n        var position = i - data.index;\n        var newValue = current + position * data.increment;\n\n        if (base) {\n          newValue %= base;\n\n          if (newValue < min) {\n            newValue += base;\n          }\n        }\n\n        item.textContent = options.translate(type, data.aliases ? data.aliases[newValue] : addLeadingZero(newValue + data.offset, data.digit));\n        setData(item, DATA_NAME, type);\n        setData(item, DATA_VALUE, newValue);\n        addClass(item, \"\".concat(NAMESPACE, \"-item\"));\n\n        if (position === 0) {\n          addClass(item, CLASS_PICKED);\n          data.item = item;\n        }\n\n        data.list.appendChild(item);\n      }\n    },\n    current: function current(type, value) {\n      var date = this.date;\n      var format = this.format;\n      var token = format[type];\n\n      switch (token.charAt(0)) {\n        case 'Y':\n          if (isNumber(value)) {\n            date.setFullYear(token.length === 2 ? 2000 + value : value);\n\n            if (format.month) {\n              this.render(tokenToType(format.month));\n            }\n\n            if (format.day) {\n              this.render(tokenToType(format.day));\n            }\n          }\n\n          return date.getFullYear();\n\n        case 'M':\n          if (isNumber(value)) {\n            date.setMonth(value, // The current day should not exceed its maximum day in current month\n            Math.min(date.getDate(), getDaysInMonth(date.getFullYear(), value)));\n\n            if (format.day) {\n              this.render(tokenToType(format.day));\n            }\n          }\n\n          return date.getMonth();\n\n        case 'D':\n          if (isNumber(value)) {\n            date.setDate(value);\n          }\n\n          return date.getDate();\n\n        case 'H':\n          if (isNumber(value)) {\n            date.setHours(value);\n          }\n\n          return date.getHours();\n\n        case 'm':\n          if (isNumber(value)) {\n            date.setMinutes(value);\n          }\n\n          return date.getMinutes();\n\n        case 's':\n          if (isNumber(value)) {\n            date.setSeconds(value);\n          }\n\n          return date.getSeconds();\n\n        case 'S':\n          if (isNumber(value)) {\n            date.setMilliseconds(value);\n          }\n\n          return date.getMilliseconds();\n\n        default:\n      }\n\n      return date;\n    },\n    getValue: function getValue() {\n      var element = this.element;\n      return this.isInput ? element.value : element.textContent;\n    },\n    setValue: function setValue(value) {\n      var element = this.element;\n\n      if (this.isInput) {\n        element.value = value;\n      } else if (this.options.container) {\n        element.textContent = value;\n      }\n    },\n    open: function open() {\n      var body = this.body;\n      body.style.overflow = 'hidden';\n      body.style.paddingRight = \"\".concat(this.scrollBarWidth + (parseFloat(this.initialBodyPaddingRight) || 0), \"px\");\n    },\n    close: function close() {\n      var body = this.body;\n      body.style.overflow = '';\n      body.style.paddingRight = this.initialBodyPaddingRight;\n    }\n  };\n  var methods = {\n    /**\n     * Show the picker.\n     * @param {boolean} [immediate=false] - Indicate if show the picker immediately or not.\n     * @returns {Picker} this\n     */\n    show: function show() {\n      var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var element = this.element,\n          picker = this.picker;\n\n      if (this.inline || this.shown) {\n        return this;\n      }\n\n      if (dispatchEvent(element, EVENT_SHOW) === false) {\n        return this;\n      }\n\n      this.shown = true;\n      this.open();\n      addClass(picker, CLASS_OPEN);\n\n      var done = function done() {\n        dispatchEvent(element, EVENT_SHOWN);\n      };\n\n      if (!immediate) {\n        // Reflow to enable transition\n        // eslint-disable-next-line\n        picker.offsetWidth;\n      }\n\n      addClass(picker, CLASS_OPENED);\n\n      if (immediate) {\n        done();\n      } else {\n        setTimeout(done, 300);\n      }\n\n      return this;\n    },\n\n    /**\n     * Hide the picker.\n     * @param {boolean} [immediate=false] - Indicate if hide the picker immediately or not.\n     * @returns {Picker} this\n     */\n    hide: function hide() {\n      var _this = this;\n\n      var immediate = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var element = this.element,\n          picker = this.picker;\n\n      if (this.inline || !this.shown) {\n        return this;\n      }\n\n      if (dispatchEvent(element, EVENT_HIDE) === false) {\n        return this;\n      }\n\n      this.shown = false;\n      removeClass(picker, CLASS_OPENED);\n\n      var done = function done() {\n        _this.close();\n\n        removeClass(picker, CLASS_OPEN);\n        dispatchEvent(element, EVENT_HIDDEN);\n      };\n\n      if (immediate) {\n        done();\n      } else {\n        setTimeout(done, 300);\n      }\n\n      return this;\n    },\n\n    /**\n     * Pick to the previous item.\n     * @param {string} type - The column type.\n     * @returns {Picker} this\n     */\n    prev: function prev(type) {\n      var options = this.options;\n      var token = this.format[type];\n      var data = this.data[type];\n      var list = data.list;\n      var item = list.lastElementChild;\n      var max = isFunction(data.max) ? data.max() : data.max;\n      var min = isFunction(data.min) ? data.min() : data.min;\n      var prev = data.item.previousElementSibling;\n      var value = Number(getData(list.firstElementChild, DATA_VALUE)) - data.increment;\n\n      if (value < min) {\n        value += max - min + 1;\n      }\n\n      item.textContent = options.translate(type, data.aliases ? data.aliases[value] : addLeadingZero(value + data.offset, token.length));\n      setData(item, DATA_VALUE, value);\n\n      if (prev) {\n        removeClass(data.item, CLASS_PICKED);\n        addClass(prev, CLASS_PICKED);\n        data.item = prev;\n      }\n\n      list.insertBefore(item, list.firstElementChild);\n      data.current = Number(getData(data.item, DATA_VALUE));\n      this.current(type, data.current);\n\n      if (this.inline && options.container) {\n        this.pick();\n      }\n\n      return this;\n    },\n\n    /**\n     * Pick to the next item.\n     * @param {String} type - The column type.\n     * @returns {Picker} this\n     */\n    next: function next(type) {\n      var options = this.options;\n      var token = this.format[type];\n      var data = this.data[type];\n      var list = data.list;\n      var item = list.firstElementChild;\n      var max = isFunction(data.max) ? data.max() : data.max;\n      var min = isFunction(data.min) ? data.min() : data.min;\n      var next = data.item.nextElementSibling;\n      var value = Number(getData(list.lastElementChild, DATA_VALUE)) + data.increment;\n\n      if (value > max) {\n        value -= max - min + 1;\n      }\n\n      item.textContent = options.translate(type, data.aliases ? data.aliases[value] : addLeadingZero(value + data.offset, token.length));\n      setData(item, DATA_VALUE, value);\n      list.appendChild(item);\n\n      if (next) {\n        removeClass(data.item, CLASS_PICKED);\n        addClass(next, CLASS_PICKED);\n        data.item = next;\n      }\n\n      data.current = Number(getData(data.item, DATA_VALUE));\n      this.current(type, data.current);\n\n      if (this.inline && options.container) {\n        this.pick();\n      }\n\n      return this;\n    },\n    // Pick the current date to the target element.\n    pick: function pick() {\n      var element = this.element;\n\n      if (dispatchEvent(element, EVENT_PICK) === false) {\n        return this;\n      }\n\n      var value = this.formatDate(this.date);\n      this.setValue(value);\n\n      if (this.isInput && dispatchEvent(element, 'change') === false) {\n        this.reset();\n      }\n\n      this.hide();\n      return this;\n    },\n\n    /**\n     * Get the current date.\n     * @param {boolean} [formatted=false] - Indicate if format the date or not.\n     * @return {Date|string} The output date.\n     */\n    getDate: function getDate() {\n      var formatted = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var date = this.date;\n      return formatted ? this.formatDate(date) : new Date(date);\n    },\n\n    /**\n     * Override the current date with a new date.\n     * @param {Date|string} date - The date to set.\n     * @returns {Picker} this\n     */\n    setDate: function setDate(date) {\n      if (date) {\n        this.date = this.parseDate(date);\n        this.render();\n      }\n\n      return this;\n    },\n    // Update the picker with the current element value / text.\n    update: function update() {\n      this.date = this.parseDate(this.getValue());\n      this.render();\n      return this;\n    },\n    // Reset the picker and element value / text.\n    reset: function reset() {\n      this.setValue(this.initialValue);\n      this.date = new Date(this.initialDate);\n      this.render();\n      return this;\n    },\n\n    /**\n     * Parse a date with the set date format.\n     * @param {Date|string} date - The date to parse.\n     * @returns {Date} The parsed date object.\n     */\n    parseDate: function parseDate(date) {\n      var options = this.options,\n          format = this.format;\n      var digits = [];\n\n      if (isDate(date)) {\n        return new Date(date);\n      }\n\n      if (isString(date)) {\n        var groups = [].concat(_toConsumableArray(options.months), _toConsumableArray(options.monthsShort), ['\\\\d+']);\n        digits = date.match(new RegExp(\"(\".concat(groups.join('|'), \")\"), 'g')); // Parse `11111111` (YYYYMMDD) to ['1111', '11', '11']\n\n        if (digits && date.length === options.format.length && digits.length !== format.tokens.length) {\n          digits = format.tokens.map(function (token) {\n            return date.substr(options.format.indexOf(token), token.length);\n          });\n        }\n\n        if (!digits || digits.length !== format.tokens.length) {\n          return new Date();\n        }\n      }\n\n      var parsedDate = new Date();\n      digits.forEach(function (digit, i) {\n        var token = format.tokens[i];\n        var n = Number(digit);\n\n        switch (token) {\n          case 'YYYY':\n          case 'YYY':\n          case 'Y':\n            {\n              var index = date.indexOf(digit);\n              var isHyphen = date.substr(index - 1, 1) === '-';\n              var isBC = index > 1 && isHyphen && /\\S/.test(date.substr(index - 2, 1)) || index === 1 && isHyphen;\n              parsedDate.setFullYear(isBC ? -n : n);\n              break;\n            }\n\n          case 'YY':\n            parsedDate.setFullYear(2000 + n);\n            break;\n\n          case 'MMMM':\n            parsedDate.setMonth(options.months.indexOf(digit));\n            break;\n\n          case 'MMM':\n            parsedDate.setMonth(options.monthsShort.indexOf(digit));\n            break;\n\n          case 'MM':\n          case 'M':\n            parsedDate.setMonth(n - 1);\n            break;\n\n          case 'DD':\n          case 'D':\n            parsedDate.setDate(n);\n            break;\n\n          case 'HH':\n          case 'H':\n            parsedDate.setHours(n);\n            break;\n\n          case 'mm':\n          case 'm':\n            parsedDate.setMinutes(n);\n            break;\n\n          case 'ss':\n          case 's':\n            parsedDate.setSeconds(n);\n            break;\n\n          case 'SSS':\n          case 'SS':\n          case 'S':\n            parsedDate.setMilliseconds(n);\n            break;\n\n          default:\n        }\n      });\n      return parsedDate;\n    },\n\n    /**\n     * Format a date object to a string with the set date format.\n     * @param {Date} date - The date to format.\n     * @return {string} THe formatted date.\n     */\n    formatDate: function formatDate(date) {\n      var options = this.options,\n          format = this.format;\n      var formatted = '';\n\n      if (isValidDate(date)) {\n        var year = date.getFullYear();\n        var month = date.getMonth();\n        var day = date.getDate();\n        var hours = date.getHours();\n        var minutes = date.getMinutes();\n        var seconds = date.getSeconds();\n        var milliseconds = date.getMilliseconds();\n        formatted = options.format;\n        format.tokens.forEach(function (token) {\n          var replacement = '';\n\n          switch (token) {\n            case 'YYYY':\n            case 'YYY':\n            case 'Y':\n              replacement = addLeadingZero(year, token.length);\n              break;\n\n            case 'YY':\n              replacement = addLeadingZero(year % 100, 2);\n              break;\n\n            case 'MMMM':\n              replacement = options.months[month];\n              break;\n\n            case 'MMM':\n              replacement = options.monthsShort[month];\n              break;\n\n            case 'MM':\n            case 'M':\n              replacement = addLeadingZero(month + 1, token.length);\n              break;\n\n            case 'DD':\n            case 'D':\n              replacement = addLeadingZero(day, token.length);\n              break;\n\n            case 'HH':\n            case 'H':\n              replacement = addLeadingZero(hours, token.length);\n              break;\n\n            case 'mm':\n            case 'm':\n              replacement = addLeadingZero(minutes, token.length);\n              break;\n\n            case 'ss':\n            case 's':\n              replacement = addLeadingZero(seconds, token.length);\n              break;\n\n            case 'SSS':\n            case 'SS':\n            case 'S':\n              replacement = addLeadingZero(milliseconds, token.length);\n              break;\n\n            default:\n          }\n\n          formatted = formatted.replace(token, replacement);\n        });\n      }\n\n      return formatted;\n    },\n    // Destroy the picker and remove the instance from the target element.\n    destroy: function destroy() {\n      var element = this.element,\n          picker = this.picker;\n\n      if (!getData(element, NAMESPACE)) {\n        return this;\n      }\n\n      this.hide(true);\n      this.unbind();\n      removeData(element, NAMESPACE);\n      picker.parentNode.removeChild(picker);\n      return this;\n    }\n  };\n  var REGEXP_DELIMITER = /\\{\\{\\s*(\\w+)\\s*\\}\\}/g;\n  var REGEXP_INPUTS = /input|textarea/i;\n  var AnotherPicker = WINDOW.Picker;\n\n  var Picker = /*#__PURE__*/function () {\n    /**\n     * Create a new Picker.\n     * @param {Element} element - The target element for picking.\n     * @param {Object} [options={}] - The configuration options.\n     */\n    function Picker(element) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      _classCallCheck(this, Picker);\n\n      if (!element || element.nodeType !== 1) {\n        throw new Error('The first argument is required and must be an element.');\n      }\n\n      this.element = element;\n      this.options = deepAssign({}, DEFAULTS, LANGUAGES[options.language], isPlainObject(options) && options);\n      this.shown = false;\n      this.init();\n    }\n\n    _createClass(Picker, [{\n      key: \"init\",\n      value: function init() {\n        var _this = this;\n\n        var element = this.element;\n\n        if (getData(element, NAMESPACE)) {\n          return;\n        }\n\n        setData(element, NAMESPACE, this);\n        var options = this.options;\n        var isInput = REGEXP_INPUTS.test(element.tagName);\n        var inline = options.inline && (options.container || !isInput);\n        var template = document.createElement('div');\n        template.insertAdjacentHTML('afterbegin', TEMPLATE.replace(REGEXP_DELIMITER, function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          return options.text[args[1]];\n        }));\n        var picker = template.getElementsByClassName(NAMESPACE)[0];\n        var grid = picker.getElementsByClassName(\"\".concat(NAMESPACE, \"-grid\"))[0];\n        var container = options.container;\n\n        if (isString(container)) {\n          container = document.querySelector(container);\n        }\n\n        if (inline) {\n          addClass(picker, CLASS_OPEN);\n          addClass(picker, CLASS_OPENED);\n\n          if (!container) {\n            container = element;\n          }\n        } else {\n          var ownerDocument = element.ownerDocument;\n          var body = ownerDocument.body || ownerDocument.documentElement;\n          this.body = body;\n          this.scrollBarWidth = WINDOW.innerWidth - ownerDocument.documentElement.clientWidth;\n          this.initialBodyPaddingRight = WINDOW.getComputedStyle(body).paddingRight;\n          addClass(picker, \"\".concat(NAMESPACE, \"-fixed\"));\n\n          if (!container) {\n            container = document.body;\n          }\n        }\n\n        this.isInput = isInput;\n        this.inline = inline;\n        this.container = container;\n        this.picker = picker;\n        this.grid = grid;\n        this.cell = null;\n        this.format = parseFormat(options.format);\n        var initialValue = this.getValue();\n        var date = this.parseDate(options.date || initialValue);\n        this.date = date;\n        this.initialDate = new Date(date);\n        this.initialValue = initialValue;\n        this.data = {};\n        var rows = Number(options.rows);\n\n        if (!(rows % 2)) {\n          rows += 1;\n        }\n\n        options.rows = rows || 5;\n        addClass(grid, \"\".concat(NAMESPACE, \"-\").concat(options.rows > 1 ? 'multiple' : 'single'));\n\n        if (options.controls) {\n          addClass(grid, \"\".concat(NAMESPACE, \"-controls\"));\n        }\n\n        var headers = options.headers,\n            increment = options.increment;\n\n        if (headers) {\n          addClass(grid, \"\".concat(NAMESPACE, \"-headers\")); // TODO: Drop the `headers` option's object support in v2.\n\n          headers = isPlainObject(headers) ? headers : options.text;\n        }\n\n        if (!isPlainObject(increment)) {\n          increment = {\n            year: increment,\n            month: increment,\n            day: increment,\n            hour: increment,\n            minute: increment,\n            second: increment,\n            millisecond: increment\n          };\n        }\n\n        this.format.tokens.forEach(function (token) {\n          var type = tokenToType(token);\n          var cell = document.createElement('div');\n          var cellBody = document.createElement('div');\n          var list = document.createElement('ul');\n          var data = {\n            digit: token.length,\n            increment: Math.abs(Number(increment[type])) || 1,\n            list: list,\n            max: Infinity,\n            min: -Infinity,\n            index: Math.floor((options.rows + 2) / 2),\n            offset: 0\n          };\n\n          switch (token.charAt(0)) {\n            case 'Y':\n              if (data.digit === 2) {\n                data.max = 99;\n                data.min = 0;\n              }\n\n              break;\n\n            case 'M':\n              data.max = 11;\n              data.min = 0;\n              data.offset = 1;\n\n              if (data.digit === 3) {\n                data.aliases = options.monthsShort;\n              } else if (data.digit === 4) {\n                data.aliases = options.months;\n              }\n\n              break;\n\n            case 'D':\n              // XXX: Use the latest date to calculate the max day (#23)\n              data.max = function () {\n                return getDaysInMonth(_this.date.getFullYear(), _this.date.getMonth());\n              };\n\n              data.min = 1;\n              break;\n\n            case 'H':\n              data.max = 23;\n              data.min = 0;\n              break;\n\n            case 'm':\n              data.max = 59;\n              data.min = 0;\n              break;\n\n            case 's':\n              data.max = 59;\n              data.min = 0;\n              break;\n\n            case 'S':\n              data.max = 999;\n              data.min = 0;\n              break;\n\n            default:\n          }\n\n          setData(cell, DATA_TYPE, type);\n          setData(cell, DATA_TOKEN, token);\n\n          if (headers) {\n            var cellHeader = document.createElement('div');\n            addClass(cellHeader, \"\".concat(NAMESPACE, \"-cell__header\"));\n            cellHeader.textContent = headers[type] || type[0].toUpperCase() + type.substr(1);\n            cell.appendChild(cellHeader);\n          }\n\n          if (options.controls) {\n            var prev = document.createElement('div');\n            addClass(prev, \"\".concat(NAMESPACE, \"-cell__control\"));\n            addClass(prev, \"\".concat(NAMESPACE, \"-cell__control--prev\"));\n            setData(prev, DATA_ACTION, ACTION_PREV);\n            cell.appendChild(prev);\n          }\n\n          addClass(list, \"\".concat(NAMESPACE, \"-list\"));\n          addClass(cellBody, \"\".concat(NAMESPACE, \"-cell__body\"));\n          addClass(cell, \"\".concat(NAMESPACE, \"-cell\"));\n          addClass(cell, \"\".concat(NAMESPACE, \"-\").concat(type, \"s\"));\n          cellBody.appendChild(list);\n          cell.appendChild(cellBody);\n\n          if (options.controls) {\n            var next = document.createElement('div');\n            addClass(next, \"\".concat(NAMESPACE, \"-cell__control\"));\n            addClass(next, \"\".concat(NAMESPACE, \"-cell__control--next\"));\n            setData(next, DATA_ACTION, ACTION_NEXT);\n            cell.appendChild(next);\n          }\n\n          grid.appendChild(cell);\n          _this.data[type] = data;\n\n          _this.render(type);\n        });\n\n        if (inline) {\n          container.innerHTML = '';\n        }\n\n        container.appendChild(picker);\n        this.bind();\n      }\n      /**\n       * Get the no conflict picker class.\n       * @returns {Picker} The picker class.\n       */\n\n    }], [{\n      key: \"noConflict\",\n      value: function noConflict() {\n        WINDOW.Picker = AnotherPicker;\n        return Picker;\n      }\n      /**\n       * Change the default options.\n       * @param {Object} options - The new default options.\n       */\n\n    }, {\n      key: \"setDefaults\",\n      value: function setDefaults(options) {\n        deepAssign(DEFAULTS, LANGUAGES[options.language], isPlainObject(options) && options);\n      }\n    }]);\n\n    return Picker;\n  }();\n\n  deepAssign(Picker.prototype, events, handlers, helpers, methods);\n  Picker.languages = LANGUAGES;\n  return Picker;\n});\n\n//# sourceURL=webpack:///../node_modules/pickerjs/dist/picker.js?");

/***/ })

}]);